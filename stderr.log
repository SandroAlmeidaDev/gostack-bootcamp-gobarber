Caught exception: ValidationError: {
  "_readableState": {
    "objectMode": false,
    "highWaterMark": 16384,
    "buffer": {
      "head": null,
      "tail": null,
      "length": 0
    },
    "length": 0,
    "pipes": [],
    "flowing": null,
    "ended": true,
    "endEmitted": false,
    "reading": false,
    "constructed": true,
    "sync": true,
    "needReadable": false,
    "emittedReadable": false,
    "readableListening": false,
    "resumeScheduled": false,
    "errorEmitted": false,
    "emitClose": true,
    "autoDestroy": true,
    "destroyed": false,
    "errored": null,
    "closed": false,
    "closeEmitted": false,
    "defaultEncoding": "utf8",
    "awaitDrainWriters": null,
    "multiAwaitDrain": false,
    "readingMore": true,
    "decoder": null,
    "encoding": null
  },
  "_events": {
    "end": function clearRequestTimeout(req) {\r\n  if (!req) {\r\n    req = this;\r\n  }\r\n\r\n  if (!req[kRequestTimeout]) {\r\n    return;\r\n  }\r\n\r\n  debug('requestTimeout timer cleared');\r\n  clearTimeout(req[kRequestTimeout]);\r\n  req[kRequestTimeout] = undefined;\r\n}
  },
  "_eventsCount": 1,
  "socket": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": [],
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "constructed": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": true,
      "destroyed": false,
      "errored": null,
      "closed": false,
      "closeEmitted": false,
      "defaultEncoding": "utf8",
      "awaitDrainWriters": null,
      "multiAwaitDrain": false,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "_events": {
      "end": [
        function onReadableStreamEnd() {\r\n  if (!this.allowHalfOpen) {\r\n    this.write = writeAfterFIN;\r\n  }\r\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\r\n  const req = this.parser && this.parser.incoming;\r\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\r\n  const res = this._httpMessage;\r\n  const resTimeout = res && res.emit('timeout', this);\r\n  const serverTimeout = this.server.emit('timeout', this);\r\n\r\n  if (!reqTimeout && !resTimeout && !serverTimeout)\r\n    this.destroy();\r\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\r\n  // Ignore further errors\r\n  this.removeListener('error', socketOnError);\r\n  this.on('error', noop);\r\n\r\n  if (!this.server.emit('clientError', e, this)) {\r\n    if (this.writable && this.bytesWritten === 0) {\r\n      let response;\r\n\r\n      switch (e.code) {\r\n        case 'HPE_HEADER_OVERFLOW':\r\n          response = requestHeaderFieldsTooLargeResponse;\r\n          break;\r\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\r\n          response = requestTimeoutResponse;\r\n          break;\r\n        default:\r\n          response = badRequestResponse;\r\n          break;\r\n      }\r\n\r\n      this.write(response);\r\n    }\r\n    this.destroy(e);\r\n  }\r\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\r\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\r\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\r\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\r\n  // listener, onServerResponseClose is still in that copy of the listeners\r\n  // array. That is, in the example below, b still gets called even though\r\n  // it's been removed by a:\r\n  //\r\n  //   var EventEmitter = require('events');\r\n  //   var obj = new EventEmitter();\r\n  //   obj.on('event', a);\r\n  //   obj.on('event', b);\r\n  //   function a() { obj.removeListener('event', b) }\r\n  //   function b() { throw \"BAM!\" }\r\n  //   obj.emit('event');  // throws\r\n  //\r\n  // Ergo, we need to deal with stale 'close' events and handle the case\r\n  // where the ServerResponse object has already been deconstructed.\r\n  // Fortunately, that requires only a single if check. :-)\r\n  if (this._httpMessage) {\r\n    this._httpMessage.destroyed = true;\r\n    this._httpMessage._closed = true;\r\n    this._httpMessage.emit('close');\r\n  }\r\n}
      ],
      "drain": function () { [native code] },
      "resume": function onSocketResume() {\r\n  // It may seem that the socket is resumed, but this is an enemy's trick to\r\n  // deceive us! `resume` is emitted asynchronously, and may be called from\r\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\r\n  // state.\r\n  //\r\n  // We don't care about stream semantics for the consumed socket anyway.\r\n  if (this._paused) {\r\n    this.pause();\r\n    return;\r\n  }\r\n\r\n  if (this._handle && !this._handle.reading) {\r\n    this._handle.reading = true;\r\n    this._handle.readStart();\r\n  }\r\n},
      "pause": function onSocketPause() {\r\n  if (this._handle && this._handle.reading) {\r\n    this._handle.reading = false;\r\n    this._handle.readStop();\r\n  }\r\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": false,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "afterWriteTickInfo": null,
      "buffered": [],
      "bufferedIndex": 0,
      "allBuffers": true,
      "allNoop": true,
      "pendingcb": 0,
      "constructed": true,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": true,
      "errored": null,
      "closed": false,
      "closeEmitted": false
    },
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
      },
      "_eventsCount": 2,
      "_connections": 2,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 0,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 60000,
      "requestTimeout": 0,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
      },
      "_eventsCount": 2,
      "_connections": 2,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 0,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 60000,
      "requestTimeout": 0,
      "_connectionKey": "6::::3333"
    },
    "parser": {
      "0": function () { [native code] },
      "1": function parserOnHeaders(headers, url) {\r\n  // Once we exceeded headers limit - stop collecting them\r\n  if (this.maxHeaderPairs <= 0 ||\r\n      this._headers.length < this.maxHeaderPairs) {\r\n    this._headers = this._headers.concat(headers);\r\n  }\r\n  this._url += url;\r\n},
      "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\r\n                                 url, statusCode, statusMessage, upgrade,\r\n                                 shouldKeepAlive) {\r\n  const parser = this;\r\n  const { socket } = parser;\r\n\r\n  if (headers === undefined) {\r\n    headers = parser._headers;\r\n    parser._headers = [];\r\n  }\r\n\r\n  if (url === undefined) {\r\n    url = parser._url;\r\n    parser._url = '';\r\n  }\r\n\r\n  // Parser is also used by http client\r\n  const ParserIncomingMessage = (socket && socket.server &&\r\n                                 socket.server[kIncomingMessage]) ||\r\n                                 IncomingMessage;\r\n\r\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\r\n  incoming.httpVersionMajor = versionMajor;\r\n  incoming.httpVersionMinor = versionMinor;\r\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\r\n  incoming.url = url;\r\n  incoming.upgrade = upgrade;\r\n\r\n  if (socket) {\r\n    debug('requestTimeout timer moved to req');\r\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\r\n    incoming.socket[kRequestTimeout] = undefined;\r\n  }\r\n\r\n  let n = headers.length;\r\n\r\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\r\n  if (parser.maxHeaderPairs > 0)\r\n    n = MathMin(n, parser.maxHeaderPairs);\r\n\r\n  incoming._addHeaderLines(headers, n);\r\n\r\n  if (typeof method === 'number') {\r\n    // server only\r\n    incoming.method = methods[method];\r\n  } else {\r\n    // client only\r\n    incoming.statusCode = statusCode;\r\n    incoming.statusMessage = statusMessage;\r\n  }\r\n\r\n  return parser.onIncoming(incoming, shouldKeepAlive);\r\n},
      "3": function parserOnBody(b, start, len) {\r\n  const stream = this.incoming;\r\n\r\n  // If the stream has already been removed, then drop it.\r\n  if (stream === null)\r\n    return;\r\n\r\n  // Pretend this was the result of a stream._read call.\r\n  if (len > 0 && !stream._dumped) {\r\n    const slice = b.slice(start, start + len);\r\n    const ret = stream.push(slice);\r\n    if (!ret)\r\n      readStop(this.socket);\r\n  }\r\n},
      "4": function parserOnMessageComplete() {\r\n  const parser = this;\r\n  const stream = parser.incoming;\r\n\r\n  if (stream !== null) {\r\n    stream.complete = true;\r\n    // Emit any trailing headers.\r\n    const headers = parser._headers;\r\n    if (headers.length) {\r\n      stream._addHeaderLines(headers, headers.length);\r\n      parser._headers = [];\r\n      parser._url = '';\r\n    }\r\n\r\n    // For emit end event\r\n    stream.push(null);\r\n  }\r\n\r\n  // Force to read the next incoming message\r\n  readStart(parser.socket);\r\n},
      "5": function () { [native code] },
      "6": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.socket]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": [],
          "flowing": null,
          "ended": true,
          "endEmitted": false,
          "reading": false,
          "constructed": true,
          "sync": true,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "errorEmitted": false,
          "emitClose": true,
          "autoDestroy": true,
          "destroyed": false,
          "errored": null,
          "closed": false,
          "closeEmitted": false,
          "defaultEncoding": "utf8",
          "awaitDrainWriters": null,
          "multiAwaitDrain": false,
          "readingMore": true,
          "decoder": null,
          "encoding": null
        },
        "_events": {
          "end": function clearRequestTimeout(req) {\r\n  if (!req) {\r\n    req = this;\r\n  }\r\n\r\n  if (!req[kRequestTimeout]) {\r\n    return;\r\n  }\r\n\r\n  debug('requestTimeout timer cleared');\r\n  clearTimeout(req[kRequestTimeout]);\r\n  req[kRequestTimeout] = undefined;\r\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "rawHeaders": [
          "Host",
          "localhost:3333",
          "Connection",
          "keep-alive",
          "User-Agent",
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36",
          "Accept",
          "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
          "Sec-Fetch-Site",
          "same-origin",
          "Sec-Fetch-Mode",
          "no-cors",
          "Sec-Fetch-Dest",
          "image",
          "Referer",
          "http://localhost:3333/files/a42fcadb549b6b92f556-foto-email.jpg",
          "Accept-Encoding",
          "gzip, deflate, br",
          "Accept-Language",
          "pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7",
          "Cookie",
          "_ga=GA1.1.610406130.1604894114"
        ],
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/favicon.ico",
        "method": "GET",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": false,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/favicon.ico",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/favicon.ico",
          "path": "/favicon.ico",
          "href": "/favicon.ico",
          "_raw": "/favicon.ico"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "destroyed": false,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "_defaultKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "_closed": false,
          "socket": "[Circular ~.socket]",
          "_header": null,
          "_keepAliveTimeout": 5000,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.socket.parser.incoming]",
          "locals": {}
        },
        "body": {}
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] }
    },
    "on": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
    "addListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
    "prependListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
    "setEncoding": function socketSetEncoding() {\r\n  throw new ERR_HTTP_SOCKET_ENCODING();\r\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "destroyed": false,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "_defaultKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "_closed": false,
      "socket": "[Circular ~.socket]",
      "_header": null,
      "_keepAliveTimeout": 5000,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": [],
          "flowing": null,
          "ended": true,
          "endEmitted": false,
          "reading": false,
          "constructed": true,
          "sync": true,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "errorEmitted": false,
          "emitClose": true,
          "autoDestroy": true,
          "destroyed": false,
          "errored": null,
          "closed": false,
          "closeEmitted": false,
          "defaultEncoding": "utf8",
          "awaitDrainWriters": null,
          "multiAwaitDrain": false,
          "readingMore": true,
          "decoder": null,
          "encoding": null
        },
        "_events": {
          "end": function clearRequestTimeout(req) {\r\n  if (!req) {\r\n    req = this;\r\n  }\r\n\r\n  if (!req[kRequestTimeout]) {\r\n    return;\r\n  }\r\n\r\n  debug('requestTimeout timer cleared');\r\n  clearTimeout(req[kRequestTimeout]);\r\n  req[kRequestTimeout] = undefined;\r\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.socket]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "rawHeaders": [
          "Host",
          "localhost:3333",
          "Connection",
          "keep-alive",
          "User-Agent",
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36",
          "Accept",
          "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
          "Sec-Fetch-Site",
          "same-origin",
          "Sec-Fetch-Mode",
          "no-cors",
          "Sec-Fetch-Dest",
          "image",
          "Referer",
          "http://localhost:3333/files/a42fcadb549b6b92f556-foto-email.jpg",
          "Accept-Encoding",
          "gzip, deflate, br",
          "Accept-Language",
          "pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7",
          "Cookie",
          "_ga=GA1.1.610406130.1604894114"
        ],
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/favicon.ico",
        "method": "GET",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.socket]",
        "_consuming": false,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/favicon.ico",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/favicon.ico",
          "path": "/favicon.ico",
          "href": "/favicon.ico",
          "_raw": "/favicon.ico"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.socket._httpMessage]",
        "body": {}
      },
      "locals": {}
    },
    "timeout": 0,
    "_peername": {
      "address": "::1",
      "family": "IPv6",
      "port": 7763
    }
  },
  "httpVersionMajor": 1,
  "httpVersionMinor": 1,
  "httpVersion": "1.1",
  "complete": true,
  "rawHeaders": [
    "Host",
    "localhost:3333",
    "Connection",
    "keep-alive",
    "User-Agent",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36",
    "Accept",
    "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
    "Sec-Fetch-Site",
    "same-origin",
    "Sec-Fetch-Mode",
    "no-cors",
    "Sec-Fetch-Dest",
    "image",
    "Referer",
    "http://localhost:3333/files/a42fcadb549b6b92f556-foto-email.jpg",
    "Accept-Encoding",
    "gzip, deflate, br",
    "Accept-Language",
    "pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7",
    "Cookie",
    "_ga=GA1.1.610406130.1604894114"
  ],
  "rawTrailers": [],
  "aborted": false,
  "upgrade": false,
  "url": "/favicon.ico",
  "method": "GET",
  "statusMessage": null,
  "client": {
    "connecting": false,
    "_hadError": false,
    "_parent": null,
    "_host": null,
    "_readableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "buffer": {
        "head": null,
        "tail": null,
        "length": 0
      },
      "length": 0,
      "pipes": [],
      "flowing": true,
      "ended": false,
      "endEmitted": false,
      "reading": true,
      "constructed": true,
      "sync": false,
      "needReadable": true,
      "emittedReadable": false,
      "readableListening": false,
      "resumeScheduled": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": true,
      "destroyed": false,
      "errored": null,
      "closed": false,
      "closeEmitted": false,
      "defaultEncoding": "utf8",
      "awaitDrainWriters": null,
      "multiAwaitDrain": false,
      "readingMore": false,
      "decoder": null,
      "encoding": null
    },
    "_events": {
      "end": [
        function onReadableStreamEnd() {\r\n  if (!this.allowHalfOpen) {\r\n    this.write = writeAfterFIN;\r\n  }\r\n},
        function () { [native code] }
      ],
      "timeout": function socketOnTimeout() {\r\n  const req = this.parser && this.parser.incoming;\r\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\r\n  const res = this._httpMessage;\r\n  const resTimeout = res && res.emit('timeout', this);\r\n  const serverTimeout = this.server.emit('timeout', this);\r\n\r\n  if (!reqTimeout && !resTimeout && !serverTimeout)\r\n    this.destroy();\r\n},
      "data": function () { [native code] },
      "error": function socketOnError(e) {\r\n  // Ignore further errors\r\n  this.removeListener('error', socketOnError);\r\n  this.on('error', noop);\r\n\r\n  if (!this.server.emit('clientError', e, this)) {\r\n    if (this.writable && this.bytesWritten === 0) {\r\n      let response;\r\n\r\n      switch (e.code) {\r\n        case 'HPE_HEADER_OVERFLOW':\r\n          response = requestHeaderFieldsTooLargeResponse;\r\n          break;\r\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\r\n          response = requestTimeoutResponse;\r\n          break;\r\n        default:\r\n          response = badRequestResponse;\r\n          break;\r\n      }\r\n\r\n      this.write(response);\r\n    }\r\n    this.destroy(e);\r\n  }\r\n},
      "close": [
        function () { [native code] },
        function onServerResponseClose() {\r\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\r\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\r\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\r\n  // listener, onServerResponseClose is still in that copy of the listeners\r\n  // array. That is, in the example below, b still gets called even though\r\n  // it's been removed by a:\r\n  //\r\n  //   var EventEmitter = require('events');\r\n  //   var obj = new EventEmitter();\r\n  //   obj.on('event', a);\r\n  //   obj.on('event', b);\r\n  //   function a() { obj.removeListener('event', b) }\r\n  //   function b() { throw \"BAM!\" }\r\n  //   obj.emit('event');  // throws\r\n  //\r\n  // Ergo, we need to deal with stale 'close' events and handle the case\r\n  // where the ServerResponse object has already been deconstructed.\r\n  // Fortunately, that requires only a single if check. :-)\r\n  if (this._httpMessage) {\r\n    this._httpMessage.destroyed = true;\r\n    this._httpMessage._closed = true;\r\n    this._httpMessage.emit('close');\r\n  }\r\n}
      ],
      "drain": function () { [native code] },
      "resume": function onSocketResume() {\r\n  // It may seem that the socket is resumed, but this is an enemy's trick to\r\n  // deceive us! `resume` is emitted asynchronously, and may be called from\r\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\r\n  // state.\r\n  //\r\n  // We don't care about stream semantics for the consumed socket anyway.\r\n  if (this._paused) {\r\n    this.pause();\r\n    return;\r\n  }\r\n\r\n  if (this._handle && !this._handle.reading) {\r\n    this._handle.reading = true;\r\n    this._handle.readStart();\r\n  }\r\n},
      "pause": function onSocketPause() {\r\n  if (this._handle && this._handle.reading) {\r\n    this._handle.reading = false;\r\n    this._handle.readStop();\r\n  }\r\n}
    },
    "_eventsCount": 8,
    "_writableState": {
      "objectMode": false,
      "highWaterMark": 16384,
      "finalCalled": false,
      "needDrain": false,
      "ending": false,
      "ended": false,
      "finished": false,
      "destroyed": false,
      "decodeStrings": false,
      "defaultEncoding": "utf8",
      "length": 0,
      "writing": false,
      "corked": 0,
      "sync": false,
      "bufferProcessing": false,
      "onwrite": function () { [native code] },
      "writecb": null,
      "writelen": 0,
      "afterWriteTickInfo": null,
      "buffered": [],
      "bufferedIndex": 0,
      "allBuffers": true,
      "allNoop": true,
      "pendingcb": 0,
      "constructed": true,
      "prefinished": false,
      "errorEmitted": false,
      "emitClose": false,
      "autoDestroy": true,
      "errored": null,
      "closed": false,
      "closeEmitted": false
    },
    "allowHalfOpen": true,
    "_sockname": null,
    "_pendingData": null,
    "_pendingEncoding": "",
    "server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
      },
      "_eventsCount": 2,
      "_connections": 2,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 0,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 60000,
      "requestTimeout": 0,
      "_connectionKey": "6::::3333"
    },
    "_server": {
      "_events": {
        "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
        "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
      },
      "_eventsCount": 2,
      "_connections": 2,
      "_handle": {
        "reading": false,
        "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
      },
      "_usingWorkers": false,
      "_workers": [],
      "_unref": false,
      "allowHalfOpen": true,
      "pauseOnConnect": false,
      "httpAllowHalfOpen": false,
      "timeout": 0,
      "keepAliveTimeout": 5000,
      "maxHeadersCount": null,
      "headersTimeout": 60000,
      "requestTimeout": 0,
      "_connectionKey": "6::::3333"
    },
    "parser": {
      "0": function () { [native code] },
      "1": function parserOnHeaders(headers, url) {\r\n  // Once we exceeded headers limit - stop collecting them\r\n  if (this.maxHeaderPairs <= 0 ||\r\n      this._headers.length < this.maxHeaderPairs) {\r\n    this._headers = this._headers.concat(headers);\r\n  }\r\n  this._url += url;\r\n},
      "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\r\n                                 url, statusCode, statusMessage, upgrade,\r\n                                 shouldKeepAlive) {\r\n  const parser = this;\r\n  const { socket } = parser;\r\n\r\n  if (headers === undefined) {\r\n    headers = parser._headers;\r\n    parser._headers = [];\r\n  }\r\n\r\n  if (url === undefined) {\r\n    url = parser._url;\r\n    parser._url = '';\r\n  }\r\n\r\n  // Parser is also used by http client\r\n  const ParserIncomingMessage = (socket && socket.server &&\r\n                                 socket.server[kIncomingMessage]) ||\r\n                                 IncomingMessage;\r\n\r\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\r\n  incoming.httpVersionMajor = versionMajor;\r\n  incoming.httpVersionMinor = versionMinor;\r\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\r\n  incoming.url = url;\r\n  incoming.upgrade = upgrade;\r\n\r\n  if (socket) {\r\n    debug('requestTimeout timer moved to req');\r\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\r\n    incoming.socket[kRequestTimeout] = undefined;\r\n  }\r\n\r\n  let n = headers.length;\r\n\r\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\r\n  if (parser.maxHeaderPairs > 0)\r\n    n = MathMin(n, parser.maxHeaderPairs);\r\n\r\n  incoming._addHeaderLines(headers, n);\r\n\r\n  if (typeof method === 'number') {\r\n    // server only\r\n    incoming.method = methods[method];\r\n  } else {\r\n    // client only\r\n    incoming.statusCode = statusCode;\r\n    incoming.statusMessage = statusMessage;\r\n  }\r\n\r\n  return parser.onIncoming(incoming, shouldKeepAlive);\r\n},
      "3": function parserOnBody(b, start, len) {\r\n  const stream = this.incoming;\r\n\r\n  // If the stream has already been removed, then drop it.\r\n  if (stream === null)\r\n    return;\r\n\r\n  // Pretend this was the result of a stream._read call.\r\n  if (len > 0 && !stream._dumped) {\r\n    const slice = b.slice(start, start + len);\r\n    const ret = stream.push(slice);\r\n    if (!ret)\r\n      readStop(this.socket);\r\n  }\r\n},
      "4": function parserOnMessageComplete() {\r\n  const parser = this;\r\n  const stream = parser.incoming;\r\n\r\n  if (stream !== null) {\r\n    stream.complete = true;\r\n    // Emit any trailing headers.\r\n    const headers = parser._headers;\r\n    if (headers.length) {\r\n      stream._addHeaderLines(headers, headers.length);\r\n      parser._headers = [];\r\n      parser._url = '';\r\n    }\r\n\r\n    // For emit end event\r\n    stream.push(null);\r\n  }\r\n\r\n  // Force to read the next incoming message\r\n  readStart(parser.socket);\r\n},
      "5": function () { [native code] },
      "6": function () { [native code] },
      "_headers": [],
      "_url": "",
      "socket": "[Circular ~.client]",
      "incoming": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": [],
          "flowing": null,
          "ended": true,
          "endEmitted": false,
          "reading": false,
          "constructed": true,
          "sync": true,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "errorEmitted": false,
          "emitClose": true,
          "autoDestroy": true,
          "destroyed": false,
          "errored": null,
          "closed": false,
          "closeEmitted": false,
          "defaultEncoding": "utf8",
          "awaitDrainWriters": null,
          "multiAwaitDrain": false,
          "readingMore": true,
          "decoder": null,
          "encoding": null
        },
        "_events": {
          "end": function clearRequestTimeout(req) {\r\n  if (!req) {\r\n    req = this;\r\n  }\r\n\r\n  if (!req[kRequestTimeout]) {\r\n    return;\r\n  }\r\n\r\n  debug('requestTimeout timer cleared');\r\n  clearTimeout(req[kRequestTimeout]);\r\n  req[kRequestTimeout] = undefined;\r\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "rawHeaders": [
          "Host",
          "localhost:3333",
          "Connection",
          "keep-alive",
          "User-Agent",
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36",
          "Accept",
          "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
          "Sec-Fetch-Site",
          "same-origin",
          "Sec-Fetch-Mode",
          "no-cors",
          "Sec-Fetch-Dest",
          "image",
          "Referer",
          "http://localhost:3333/files/a42fcadb549b6b92f556-foto-email.jpg",
          "Accept-Encoding",
          "gzip, deflate, br",
          "Accept-Language",
          "pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7",
          "Cookie",
          "_ga=GA1.1.610406130.1604894114"
        ],
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/favicon.ico",
        "method": "GET",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": false,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/favicon.ico",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/favicon.ico",
          "path": "/favicon.ico",
          "href": "/favicon.ico",
          "_raw": "/favicon.ico"
        },
        "params": {},
        "query": {},
        "res": {
          "_events": {
            "finish": function () { [native code] }
          },
          "_eventsCount": 1,
          "outputData": [],
          "outputSize": 0,
          "writable": true,
          "destroyed": false,
          "_last": false,
          "chunkedEncoding": false,
          "shouldKeepAlive": true,
          "_defaultKeepAlive": true,
          "useChunkedEncodingByDefault": true,
          "sendDate": true,
          "_removedConnection": false,
          "_removedContLen": false,
          "_removedTE": false,
          "_contentLength": null,
          "_hasBody": true,
          "_trailer": "",
          "finished": false,
          "_headerSent": false,
          "_closed": false,
          "socket": "[Circular ~.client]",
          "_header": null,
          "_keepAliveTimeout": 5000,
          "_onPendingData": function () { [native code] },
          "_sent100": false,
          "_expect_continue": false,
          "req": "[Circular ~.client.parser.incoming]",
          "locals": {}
        },
        "body": {}
      },
      "outgoing": null,
      "maxHeaderPairs": 2000,
      "_consumed": true,
      "onIncoming": function () { [native code] }
    },
    "on": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
    "addListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
    "prependListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
    "setEncoding": function socketSetEncoding() {\r\n  throw new ERR_HTTP_SOCKET_ENCODING();\r\n},
    "_paused": false,
    "_httpMessage": {
      "_events": {
        "finish": function () { [native code] }
      },
      "_eventsCount": 1,
      "outputData": [],
      "outputSize": 0,
      "writable": true,
      "destroyed": false,
      "_last": false,
      "chunkedEncoding": false,
      "shouldKeepAlive": true,
      "_defaultKeepAlive": true,
      "useChunkedEncodingByDefault": true,
      "sendDate": true,
      "_removedConnection": false,
      "_removedContLen": false,
      "_removedTE": false,
      "_contentLength": null,
      "_hasBody": true,
      "_trailer": "",
      "finished": false,
      "_headerSent": false,
      "_closed": false,
      "socket": "[Circular ~.client]",
      "_header": null,
      "_keepAliveTimeout": 5000,
      "_onPendingData": function () { [native code] },
      "_sent100": false,
      "_expect_continue": false,
      "req": {
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": [],
          "flowing": null,
          "ended": true,
          "endEmitted": false,
          "reading": false,
          "constructed": true,
          "sync": true,
          "needReadable": false,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "errorEmitted": false,
          "emitClose": true,
          "autoDestroy": true,
          "destroyed": false,
          "errored": null,
          "closed": false,
          "closeEmitted": false,
          "defaultEncoding": "utf8",
          "awaitDrainWriters": null,
          "multiAwaitDrain": false,
          "readingMore": true,
          "decoder": null,
          "encoding": null
        },
        "_events": {
          "end": function clearRequestTimeout(req) {\r\n  if (!req) {\r\n    req = this;\r\n  }\r\n\r\n  if (!req[kRequestTimeout]) {\r\n    return;\r\n  }\r\n\r\n  debug('requestTimeout timer cleared');\r\n  clearTimeout(req[kRequestTimeout]);\r\n  req[kRequestTimeout] = undefined;\r\n}
        },
        "_eventsCount": 1,
        "socket": "[Circular ~.client]",
        "httpVersionMajor": 1,
        "httpVersionMinor": 1,
        "httpVersion": "1.1",
        "complete": true,
        "rawHeaders": [
          "Host",
          "localhost:3333",
          "Connection",
          "keep-alive",
          "User-Agent",
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36",
          "Accept",
          "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
          "Sec-Fetch-Site",
          "same-origin",
          "Sec-Fetch-Mode",
          "no-cors",
          "Sec-Fetch-Dest",
          "image",
          "Referer",
          "http://localhost:3333/files/a42fcadb549b6b92f556-foto-email.jpg",
          "Accept-Encoding",
          "gzip, deflate, br",
          "Accept-Language",
          "pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7",
          "Cookie",
          "_ga=GA1.1.610406130.1604894114"
        ],
        "rawTrailers": [],
        "aborted": false,
        "upgrade": false,
        "url": "/favicon.ico",
        "method": "GET",
        "statusCode": null,
        "statusMessage": null,
        "client": "[Circular ~.client]",
        "_consuming": false,
        "_dumped": false,
        "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
        "baseUrl": "",
        "originalUrl": "/favicon.ico",
        "_parsedUrl": {
          "protocol": null,
          "slashes": null,
          "auth": null,
          "host": null,
          "port": null,
          "hostname": null,
          "hash": null,
          "search": null,
          "query": null,
          "pathname": "/favicon.ico",
          "path": "/favicon.ico",
          "href": "/favicon.ico",
          "_raw": "/favicon.ico"
        },
        "params": {},
        "query": {},
        "res": "[Circular ~.client._httpMessage]",
        "body": {}
      },
      "locals": {}
    },
    "timeout": 0,
    "_peername": {
      "address": "::1",
      "family": "IPv6",
      "port": 7763
    }
  },
  "_consuming": false,
  "_dumped": false,
  "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
  "baseUrl": "",
  "originalUrl": "/favicon.ico",
  "_parsedUrl": {
    "protocol": null,
    "slashes": null,
    "auth": null,
    "host": null,
    "port": null,
    "hostname": null,
    "hash": null,
    "search": null,
    "query": null,
    "pathname": "/favicon.ico",
    "path": "/favicon.ico",
    "href": "/favicon.ico",
    "_raw": "/favicon.ico"
  },
  "params": {},
  "query": {},
  "res": {
    "_events": {
      "finish": function () { [native code] }
    },
    "_eventsCount": 1,
    "outputData": [],
    "outputSize": 0,
    "writable": true,
    "destroyed": false,
    "_last": false,
    "chunkedEncoding": false,
    "shouldKeepAlive": true,
    "_defaultKeepAlive": true,
    "useChunkedEncodingByDefault": true,
    "sendDate": true,
    "_removedConnection": false,
    "_removedContLen": false,
    "_removedTE": false,
    "_contentLength": null,
    "_hasBody": true,
    "_trailer": "",
    "finished": false,
    "_headerSent": false,
    "_closed": false,
    "socket": {
      "connecting": false,
      "_hadError": false,
      "_parent": null,
      "_host": null,
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": [],
        "flowing": true,
        "ended": false,
        "endEmitted": false,
        "reading": true,
        "constructed": true,
        "sync": false,
        "needReadable": true,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": true,
        "destroyed": false,
        "errored": null,
        "closed": false,
        "closeEmitted": false,
        "defaultEncoding": "utf8",
        "awaitDrainWriters": null,
        "multiAwaitDrain": false,
        "readingMore": false,
        "decoder": null,
        "encoding": null
      },
      "_events": {
        "end": [
          function onReadableStreamEnd() {\r\n  if (!this.allowHalfOpen) {\r\n    this.write = writeAfterFIN;\r\n  }\r\n},
          function () { [native code] }
        ],
        "timeout": function socketOnTimeout() {\r\n  const req = this.parser && this.parser.incoming;\r\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\r\n  const res = this._httpMessage;\r\n  const resTimeout = res && res.emit('timeout', this);\r\n  const serverTimeout = this.server.emit('timeout', this);\r\n\r\n  if (!reqTimeout && !resTimeout && !serverTimeout)\r\n    this.destroy();\r\n},
        "data": function () { [native code] },
        "error": function socketOnError(e) {\r\n  // Ignore further errors\r\n  this.removeListener('error', socketOnError);\r\n  this.on('error', noop);\r\n\r\n  if (!this.server.emit('clientError', e, this)) {\r\n    if (this.writable && this.bytesWritten === 0) {\r\n      let response;\r\n\r\n      switch (e.code) {\r\n        case 'HPE_HEADER_OVERFLOW':\r\n          response = requestHeaderFieldsTooLargeResponse;\r\n          break;\r\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\r\n          response = requestTimeoutResponse;\r\n          break;\r\n        default:\r\n          response = badRequestResponse;\r\n          break;\r\n      }\r\n\r\n      this.write(response);\r\n    }\r\n    this.destroy(e);\r\n  }\r\n},
        "close": [
          function () { [native code] },
          function onServerResponseClose() {\r\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\r\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\r\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\r\n  // listener, onServerResponseClose is still in that copy of the listeners\r\n  // array. That is, in the example below, b still gets called even though\r\n  // it's been removed by a:\r\n  //\r\n  //   var EventEmitter = require('events');\r\n  //   var obj = new EventEmitter();\r\n  //   obj.on('event', a);\r\n  //   obj.on('event', b);\r\n  //   function a() { obj.removeListener('event', b) }\r\n  //   function b() { throw \"BAM!\" }\r\n  //   obj.emit('event');  // throws\r\n  //\r\n  // Ergo, we need to deal with stale 'close' events and handle the case\r\n  // where the ServerResponse object has already been deconstructed.\r\n  // Fortunately, that requires only a single if check. :-)\r\n  if (this._httpMessage) {\r\n    this._httpMessage.destroyed = true;\r\n    this._httpMessage._closed = true;\r\n    this._httpMessage.emit('close');\r\n  }\r\n}
        ],
        "drain": function () { [native code] },
        "resume": function onSocketResume() {\r\n  // It may seem that the socket is resumed, but this is an enemy's trick to\r\n  // deceive us! `resume` is emitted asynchronously, and may be called from\r\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\r\n  // state.\r\n  //\r\n  // We don't care about stream semantics for the consumed socket anyway.\r\n  if (this._paused) {\r\n    this.pause();\r\n    return;\r\n  }\r\n\r\n  if (this._handle && !this._handle.reading) {\r\n    this._handle.reading = true;\r\n    this._handle.readStart();\r\n  }\r\n},
        "pause": function onSocketPause() {\r\n  if (this._handle && this._handle.reading) {\r\n    this._handle.reading = false;\r\n    this._handle.readStop();\r\n  }\r\n}
      },
      "_eventsCount": 8,
      "_writableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "finalCalled": false,
        "needDrain": false,
        "ending": false,
        "ended": false,
        "finished": false,
        "destroyed": false,
        "decodeStrings": false,
        "defaultEncoding": "utf8",
        "length": 0,
        "writing": false,
        "corked": 0,
        "sync": false,
        "bufferProcessing": false,
        "onwrite": function () { [native code] },
        "writecb": null,
        "writelen": 0,
        "afterWriteTickInfo": null,
        "buffered": [],
        "bufferedIndex": 0,
        "allBuffers": true,
        "allNoop": true,
        "pendingcb": 0,
        "constructed": true,
        "prefinished": false,
        "errorEmitted": false,
        "emitClose": false,
        "autoDestroy": true,
        "errored": null,
        "closed": false,
        "closeEmitted": false
      },
      "allowHalfOpen": true,
      "_sockname": null,
      "_pendingData": null,
      "_pendingEncoding": "",
      "server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
        },
        "_eventsCount": 2,
        "_connections": 2,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 0,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 60000,
        "requestTimeout": 0,
        "_connectionKey": "6::::3333"
      },
      "_server": {
        "_events": {
          "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
          "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
        },
        "_eventsCount": 2,
        "_connections": 2,
        "_handle": {
          "reading": false,
          "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
        },
        "_usingWorkers": false,
        "_workers": [],
        "_unref": false,
        "allowHalfOpen": true,
        "pauseOnConnect": false,
        "httpAllowHalfOpen": false,
        "timeout": 0,
        "keepAliveTimeout": 5000,
        "maxHeadersCount": null,
        "headersTimeout": 60000,
        "requestTimeout": 0,
        "_connectionKey": "6::::3333"
      },
      "parser": {
        "0": function () { [native code] },
        "1": function parserOnHeaders(headers, url) {\r\n  // Once we exceeded headers limit - stop collecting them\r\n  if (this.maxHeaderPairs <= 0 ||\r\n      this._headers.length < this.maxHeaderPairs) {\r\n    this._headers = this._headers.concat(headers);\r\n  }\r\n  this._url += url;\r\n},
        "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\r\n                                 url, statusCode, statusMessage, upgrade,\r\n                                 shouldKeepAlive) {\r\n  const parser = this;\r\n  const { socket } = parser;\r\n\r\n  if (headers === undefined) {\r\n    headers = parser._headers;\r\n    parser._headers = [];\r\n  }\r\n\r\n  if (url === undefined) {\r\n    url = parser._url;\r\n    parser._url = '';\r\n  }\r\n\r\n  // Parser is also used by http client\r\n  const ParserIncomingMessage = (socket && socket.server &&\r\n                                 socket.server[kIncomingMessage]) ||\r\n                                 IncomingMessage;\r\n\r\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\r\n  incoming.httpVersionMajor = versionMajor;\r\n  incoming.httpVersionMinor = versionMinor;\r\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\r\n  incoming.url = url;\r\n  incoming.upgrade = upgrade;\r\n\r\n  if (socket) {\r\n    debug('requestTimeout timer moved to req');\r\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\r\n    incoming.socket[kRequestTimeout] = undefined;\r\n  }\r\n\r\n  let n = headers.length;\r\n\r\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\r\n  if (parser.maxHeaderPairs > 0)\r\n    n = MathMin(n, parser.maxHeaderPairs);\r\n\r\n  incoming._addHeaderLines(headers, n);\r\n\r\n  if (typeof method === 'number') {\r\n    // server only\r\n    incoming.method = methods[method];\r\n  } else {\r\n    // client only\r\n    incoming.statusCode = statusCode;\r\n    incoming.statusMessage = statusMessage;\r\n  }\r\n\r\n  return parser.onIncoming(incoming, shouldKeepAlive);\r\n},
        "3": function parserOnBody(b, start, len) {\r\n  const stream = this.incoming;\r\n\r\n  // If the stream has already been removed, then drop it.\r\n  if (stream === null)\r\n    return;\r\n\r\n  // Pretend this was the result of a stream._read call.\r\n  if (len > 0 && !stream._dumped) {\r\n    const slice = b.slice(start, start + len);\r\n    const ret = stream.push(slice);\r\n    if (!ret)\r\n      readStop(this.socket);\r\n  }\r\n},
        "4": function parserOnMessageComplete() {\r\n  const parser = this;\r\n  const stream = parser.incoming;\r\n\r\n  if (stream !== null) {\r\n    stream.complete = true;\r\n    // Emit any trailing headers.\r\n    const headers = parser._headers;\r\n    if (headers.length) {\r\n      stream._addHeaderLines(headers, headers.length);\r\n      parser._headers = [];\r\n      parser._url = '';\r\n    }\r\n\r\n    // For emit end event\r\n    stream.push(null);\r\n  }\r\n\r\n  // Force to read the next incoming message\r\n  readStart(parser.socket);\r\n},
        "5": function () { [native code] },
        "6": function () { [native code] },
        "_headers": [],
        "_url": "",
        "socket": "[Circular ~.res.socket]",
        "incoming": {
          "_readableState": {
            "objectMode": false,
            "highWaterMark": 16384,
            "buffer": {
              "head": null,
              "tail": null,
              "length": 0
            },
            "length": 0,
            "pipes": [],
            "flowing": null,
            "ended": true,
            "endEmitted": false,
            "reading": false,
            "constructed": true,
            "sync": true,
            "needReadable": false,
            "emittedReadable": false,
            "readableListening": false,
            "resumeScheduled": false,
            "errorEmitted": false,
            "emitClose": true,
            "autoDestroy": true,
            "destroyed": false,
            "errored": null,
            "closed": false,
            "closeEmitted": false,
            "defaultEncoding": "utf8",
            "awaitDrainWriters": null,
            "multiAwaitDrain": false,
            "readingMore": true,
            "decoder": null,
            "encoding": null
          },
          "_events": {
            "end": function clearRequestTimeout(req) {\r\n  if (!req) {\r\n    req = this;\r\n  }\r\n\r\n  if (!req[kRequestTimeout]) {\r\n    return;\r\n  }\r\n\r\n  debug('requestTimeout timer cleared');\r\n  clearTimeout(req[kRequestTimeout]);\r\n  req[kRequestTimeout] = undefined;\r\n}
          },
          "_eventsCount": 1,
          "socket": "[Circular ~.res.socket]",
          "httpVersionMajor": 1,
          "httpVersionMinor": 1,
          "httpVersion": "1.1",
          "complete": true,
          "rawHeaders": [
            "Host",
            "localhost:3333",
            "Connection",
            "keep-alive",
            "User-Agent",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36",
            "Accept",
            "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
            "Sec-Fetch-Site",
            "same-origin",
            "Sec-Fetch-Mode",
            "no-cors",
            "Sec-Fetch-Dest",
            "image",
            "Referer",
            "http://localhost:3333/files/a42fcadb549b6b92f556-foto-email.jpg",
            "Accept-Encoding",
            "gzip, deflate, br",
            "Accept-Language",
            "pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7",
            "Cookie",
            "_ga=GA1.1.610406130.1604894114"
          ],
          "rawTrailers": [],
          "aborted": false,
          "upgrade": false,
          "url": "/favicon.ico",
          "method": "GET",
          "statusCode": null,
          "statusMessage": null,
          "client": "[Circular ~.res.socket]",
          "_consuming": false,
          "_dumped": false,
          "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
          "baseUrl": "",
          "originalUrl": "/favicon.ico",
          "_parsedUrl": {
            "protocol": null,
            "slashes": null,
            "auth": null,
            "host": null,
            "port": null,
            "hostname": null,
            "hash": null,
            "search": null,
            "query": null,
            "pathname": "/favicon.ico",
            "path": "/favicon.ico",
            "href": "/favicon.ico",
            "_raw": "/favicon.ico"
          },
          "params": {},
          "query": {},
          "res": "[Circular ~.res]",
          "body": {}
        },
        "outgoing": null,
        "maxHeaderPairs": 2000,
        "_consumed": true,
        "onIncoming": function () { [native code] }
      },
      "on": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
      "addListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
      "prependListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
      "setEncoding": function socketSetEncoding() {\r\n  throw new ERR_HTTP_SOCKET_ENCODING();\r\n},
      "_paused": false,
      "_httpMessage": "[Circular ~.res]",
      "timeout": 0,
      "_peername": {
        "address": "::1",
        "family": "IPv6",
        "port": 7763
      }
    },
    "_header": null,
    "_keepAliveTimeout": 5000,
    "_onPendingData": function () { [native code] },
    "_sent100": false,
    "_expect_continue": false,
    "req": {
      "_readableState": {
        "objectMode": false,
        "highWaterMark": 16384,
        "buffer": {
          "head": null,
          "tail": null,
          "length": 0
        },
        "length": 0,
        "pipes": [],
        "flowing": null,
        "ended": true,
        "endEmitted": false,
        "reading": false,
        "constructed": true,
        "sync": true,
        "needReadable": false,
        "emittedReadable": false,
        "readableListening": false,
        "resumeScheduled": false,
        "errorEmitted": false,
        "emitClose": true,
        "autoDestroy": true,
        "destroyed": false,
        "errored": null,
        "closed": false,
        "closeEmitted": false,
        "defaultEncoding": "utf8",
        "awaitDrainWriters": null,
        "multiAwaitDrain": false,
        "readingMore": true,
        "decoder": null,
        "encoding": null
      },
      "_events": {
        "end": function clearRequestTimeout(req) {\r\n  if (!req) {\r\n    req = this;\r\n  }\r\n\r\n  if (!req[kRequestTimeout]) {\r\n    return;\r\n  }\r\n\r\n  debug('requestTimeout timer cleared');\r\n  clearTimeout(req[kRequestTimeout]);\r\n  req[kRequestTimeout] = undefined;\r\n}
      },
      "_eventsCount": 1,
      "socket": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": [],
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "constructed": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": true,
          "destroyed": false,
          "errored": null,
          "closed": false,
          "closeEmitted": false,
          "defaultEncoding": "utf8",
          "awaitDrainWriters": null,
          "multiAwaitDrain": false,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "_events": {
          "end": [
            function onReadableStreamEnd() {\r\n  if (!this.allowHalfOpen) {\r\n    this.write = writeAfterFIN;\r\n  }\r\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\r\n  const req = this.parser && this.parser.incoming;\r\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\r\n  const res = this._httpMessage;\r\n  const resTimeout = res && res.emit('timeout', this);\r\n  const serverTimeout = this.server.emit('timeout', this);\r\n\r\n  if (!reqTimeout && !resTimeout && !serverTimeout)\r\n    this.destroy();\r\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\r\n  // Ignore further errors\r\n  this.removeListener('error', socketOnError);\r\n  this.on('error', noop);\r\n\r\n  if (!this.server.emit('clientError', e, this)) {\r\n    if (this.writable && this.bytesWritten === 0) {\r\n      let response;\r\n\r\n      switch (e.code) {\r\n        case 'HPE_HEADER_OVERFLOW':\r\n          response = requestHeaderFieldsTooLargeResponse;\r\n          break;\r\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\r\n          response = requestTimeoutResponse;\r\n          break;\r\n        default:\r\n          response = badRequestResponse;\r\n          break;\r\n      }\r\n\r\n      this.write(response);\r\n    }\r\n    this.destroy(e);\r\n  }\r\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\r\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\r\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\r\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\r\n  // listener, onServerResponseClose is still in that copy of the listeners\r\n  // array. That is, in the example below, b still gets called even though\r\n  // it's been removed by a:\r\n  //\r\n  //   var EventEmitter = require('events');\r\n  //   var obj = new EventEmitter();\r\n  //   obj.on('event', a);\r\n  //   obj.on('event', b);\r\n  //   function a() { obj.removeListener('event', b) }\r\n  //   function b() { throw \"BAM!\" }\r\n  //   obj.emit('event');  // throws\r\n  //\r\n  // Ergo, we need to deal with stale 'close' events and handle the case\r\n  // where the ServerResponse object has already been deconstructed.\r\n  // Fortunately, that requires only a single if check. :-)\r\n  if (this._httpMessage) {\r\n    this._httpMessage.destroyed = true;\r\n    this._httpMessage._closed = true;\r\n    this._httpMessage.emit('close');\r\n  }\r\n}
          ],
          "drain": function () { [native code] },
          "resume": function onSocketResume() {\r\n  // It may seem that the socket is resumed, but this is an enemy's trick to\r\n  // deceive us! `resume` is emitted asynchronously, and may be called from\r\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\r\n  // state.\r\n  //\r\n  // We don't care about stream semantics for the consumed socket anyway.\r\n  if (this._paused) {\r\n    this.pause();\r\n    return;\r\n  }\r\n\r\n  if (this._handle && !this._handle.reading) {\r\n    this._handle.reading = true;\r\n    this._handle.readStart();\r\n  }\r\n},
          "pause": function onSocketPause() {\r\n  if (this._handle && this._handle.reading) {\r\n    this._handle.reading = false;\r\n    this._handle.readStop();\r\n  }\r\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": false,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "afterWriteTickInfo": null,
          "buffered": [],
          "bufferedIndex": 0,
          "allBuffers": true,
          "allNoop": true,
          "pendingcb": 0,
          "constructed": true,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": true,
          "errored": null,
          "closed": false,
          "closeEmitted": false
        },
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
          },
          "_eventsCount": 2,
          "_connections": 2,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 0,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 60000,
          "requestTimeout": 0,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
          },
          "_eventsCount": 2,
          "_connections": 2,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 0,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 60000,
          "requestTimeout": 0,
          "_connectionKey": "6::::3333"
        },
        "parser": {
          "0": function () { [native code] },
          "1": function parserOnHeaders(headers, url) {\r\n  // Once we exceeded headers limit - stop collecting them\r\n  if (this.maxHeaderPairs <= 0 ||\r\n      this._headers.length < this.maxHeaderPairs) {\r\n    this._headers = this._headers.concat(headers);\r\n  }\r\n  this._url += url;\r\n},
          "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\r\n                                 url, statusCode, statusMessage, upgrade,\r\n                                 shouldKeepAlive) {\r\n  const parser = this;\r\n  const { socket } = parser;\r\n\r\n  if (headers === undefined) {\r\n    headers = parser._headers;\r\n    parser._headers = [];\r\n  }\r\n\r\n  if (url === undefined) {\r\n    url = parser._url;\r\n    parser._url = '';\r\n  }\r\n\r\n  // Parser is also used by http client\r\n  const ParserIncomingMessage = (socket && socket.server &&\r\n                                 socket.server[kIncomingMessage]) ||\r\n                                 IncomingMessage;\r\n\r\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\r\n  incoming.httpVersionMajor = versionMajor;\r\n  incoming.httpVersionMinor = versionMinor;\r\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\r\n  incoming.url = url;\r\n  incoming.upgrade = upgrade;\r\n\r\n  if (socket) {\r\n    debug('requestTimeout timer moved to req');\r\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\r\n    incoming.socket[kRequestTimeout] = undefined;\r\n  }\r\n\r\n  let n = headers.length;\r\n\r\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\r\n  if (parser.maxHeaderPairs > 0)\r\n    n = MathMin(n, parser.maxHeaderPairs);\r\n\r\n  incoming._addHeaderLines(headers, n);\r\n\r\n  if (typeof method === 'number') {\r\n    // server only\r\n    incoming.method = methods[method];\r\n  } else {\r\n    // client only\r\n    incoming.statusCode = statusCode;\r\n    incoming.statusMessage = statusMessage;\r\n  }\r\n\r\n  return parser.onIncoming(incoming, shouldKeepAlive);\r\n},
          "3": function parserOnBody(b, start, len) {\r\n  const stream = this.incoming;\r\n\r\n  // If the stream has already been removed, then drop it.\r\n  if (stream === null)\r\n    return;\r\n\r\n  // Pretend this was the result of a stream._read call.\r\n  if (len > 0 && !stream._dumped) {\r\n    const slice = b.slice(start, start + len);\r\n    const ret = stream.push(slice);\r\n    if (!ret)\r\n      readStop(this.socket);\r\n  }\r\n},
          "4": function parserOnMessageComplete() {\r\n  const parser = this;\r\n  const stream = parser.incoming;\r\n\r\n  if (stream !== null) {\r\n    stream.complete = true;\r\n    // Emit any trailing headers.\r\n    const headers = parser._headers;\r\n    if (headers.length) {\r\n      stream._addHeaderLines(headers, headers.length);\r\n      parser._headers = [];\r\n      parser._url = '';\r\n    }\r\n\r\n    // For emit end event\r\n    stream.push(null);\r\n  }\r\n\r\n  // Force to read the next incoming message\r\n  readStart(parser.socket);\r\n},
          "5": function () { [native code] },
          "6": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.socket]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] }
        },
        "on": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
        "addListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
        "prependListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
        "setEncoding": function socketSetEncoding() {\r\n  throw new ERR_HTTP_SOCKET_ENCODING();\r\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]",
        "timeout": 0,
        "_peername": {
          "address": "::1",
          "family": "IPv6",
          "port": 7763
        }
      },
      "httpVersionMajor": 1,
      "httpVersionMinor": 1,
      "httpVersion": "1.1",
      "complete": true,
      "rawHeaders": [
        "Host",
        "localhost:3333",
        "Connection",
        "keep-alive",
        "User-Agent",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36",
        "Accept",
        "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",
        "Sec-Fetch-Site",
        "same-origin",
        "Sec-Fetch-Mode",
        "no-cors",
        "Sec-Fetch-Dest",
        "image",
        "Referer",
        "http://localhost:3333/files/a42fcadb549b6b92f556-foto-email.jpg",
        "Accept-Encoding",
        "gzip, deflate, br",
        "Accept-Language",
        "pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7",
        "Cookie",
        "_ga=GA1.1.610406130.1604894114"
      ],
      "rawTrailers": [],
      "aborted": false,
      "upgrade": false,
      "url": "/favicon.ico",
      "method": "GET",
      "statusCode": null,
      "statusMessage": null,
      "client": {
        "connecting": false,
        "_hadError": false,
        "_parent": null,
        "_host": null,
        "_readableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "buffer": {
            "head": null,
            "tail": null,
            "length": 0
          },
          "length": 0,
          "pipes": [],
          "flowing": true,
          "ended": false,
          "endEmitted": false,
          "reading": true,
          "constructed": true,
          "sync": false,
          "needReadable": true,
          "emittedReadable": false,
          "readableListening": false,
          "resumeScheduled": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": true,
          "destroyed": false,
          "errored": null,
          "closed": false,
          "closeEmitted": false,
          "defaultEncoding": "utf8",
          "awaitDrainWriters": null,
          "multiAwaitDrain": false,
          "readingMore": false,
          "decoder": null,
          "encoding": null
        },
        "_events": {
          "end": [
            function onReadableStreamEnd() {\r\n  if (!this.allowHalfOpen) {\r\n    this.write = writeAfterFIN;\r\n  }\r\n},
            function () { [native code] }
          ],
          "timeout": function socketOnTimeout() {\r\n  const req = this.parser && this.parser.incoming;\r\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\r\n  const res = this._httpMessage;\r\n  const resTimeout = res && res.emit('timeout', this);\r\n  const serverTimeout = this.server.emit('timeout', this);\r\n\r\n  if (!reqTimeout && !resTimeout && !serverTimeout)\r\n    this.destroy();\r\n},
          "data": function () { [native code] },
          "error": function socketOnError(e) {\r\n  // Ignore further errors\r\n  this.removeListener('error', socketOnError);\r\n  this.on('error', noop);\r\n\r\n  if (!this.server.emit('clientError', e, this)) {\r\n    if (this.writable && this.bytesWritten === 0) {\r\n      let response;\r\n\r\n      switch (e.code) {\r\n        case 'HPE_HEADER_OVERFLOW':\r\n          response = requestHeaderFieldsTooLargeResponse;\r\n          break;\r\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\r\n          response = requestTimeoutResponse;\r\n          break;\r\n        default:\r\n          response = badRequestResponse;\r\n          break;\r\n      }\r\n\r\n      this.write(response);\r\n    }\r\n    this.destroy(e);\r\n  }\r\n},
          "close": [
            function () { [native code] },
            function onServerResponseClose() {\r\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\r\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\r\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\r\n  // listener, onServerResponseClose is still in that copy of the listeners\r\n  // array. That is, in the example below, b still gets called even though\r\n  // it's been removed by a:\r\n  //\r\n  //   var EventEmitter = require('events');\r\n  //   var obj = new EventEmitter();\r\n  //   obj.on('event', a);\r\n  //   obj.on('event', b);\r\n  //   function a() { obj.removeListener('event', b) }\r\n  //   function b() { throw \"BAM!\" }\r\n  //   obj.emit('event');  // throws\r\n  //\r\n  // Ergo, we need to deal with stale 'close' events and handle the case\r\n  // where the ServerResponse object has already been deconstructed.\r\n  // Fortunately, that requires only a single if check. :-)\r\n  if (this._httpMessage) {\r\n    this._httpMessage.destroyed = true;\r\n    this._httpMessage._closed = true;\r\n    this._httpMessage.emit('close');\r\n  }\r\n}
          ],
          "drain": function () { [native code] },
          "resume": function onSocketResume() {\r\n  // It may seem that the socket is resumed, but this is an enemy's trick to\r\n  // deceive us! `resume` is emitted asynchronously, and may be called from\r\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\r\n  // state.\r\n  //\r\n  // We don't care about stream semantics for the consumed socket anyway.\r\n  if (this._paused) {\r\n    this.pause();\r\n    return;\r\n  }\r\n\r\n  if (this._handle && !this._handle.reading) {\r\n    this._handle.reading = true;\r\n    this._handle.readStart();\r\n  }\r\n},
          "pause": function onSocketPause() {\r\n  if (this._handle && this._handle.reading) {\r\n    this._handle.reading = false;\r\n    this._handle.readStop();\r\n  }\r\n}
        },
        "_eventsCount": 8,
        "_writableState": {
          "objectMode": false,
          "highWaterMark": 16384,
          "finalCalled": false,
          "needDrain": false,
          "ending": false,
          "ended": false,
          "finished": false,
          "destroyed": false,
          "decodeStrings": false,
          "defaultEncoding": "utf8",
          "length": 0,
          "writing": false,
          "corked": 0,
          "sync": false,
          "bufferProcessing": false,
          "onwrite": function () { [native code] },
          "writecb": null,
          "writelen": 0,
          "afterWriteTickInfo": null,
          "buffered": [],
          "bufferedIndex": 0,
          "allBuffers": true,
          "allNoop": true,
          "pendingcb": 0,
          "constructed": true,
          "prefinished": false,
          "errorEmitted": false,
          "emitClose": false,
          "autoDestroy": true,
          "errored": null,
          "closed": false,
          "closeEmitted": false
        },
        "allowHalfOpen": true,
        "_sockname": null,
        "_pendingData": null,
        "_pendingEncoding": "",
        "server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
          },
          "_eventsCount": 2,
          "_connections": 2,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 0,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 60000,
          "requestTimeout": 0,
          "_connectionKey": "6::::3333"
        },
        "_server": {
          "_events": {
            "request": function(req, res, next) {\n    app.handle(req, res, next);\n  },
            "connection": function connectionListener(socket) {\r\n  defaultTriggerAsyncIdScope(\r\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\r\n  );\r\n}
          },
          "_eventsCount": 2,
          "_connections": 2,
          "_handle": {
            "reading": false,
            "onconnection": function onconnection(err, clientHandle) {\r\n  const handle = this;\r\n  const self = handle[owner_symbol];\r\n\r\n  debug('onconnection');\r\n\r\n  if (err) {\r\n    self.emit('error', errnoException(err, 'accept'));\r\n    return;\r\n  }\r\n\r\n  if (self.maxConnections && self._connections >= self.maxConnections) {\r\n    clientHandle.close();\r\n    return;\r\n  }\r\n\r\n  const socket = new Socket({\r\n    handle: clientHandle,\r\n    allowHalfOpen: self.allowHalfOpen,\r\n    pauseOnCreate: self.pauseOnConnect,\r\n    readable: true,\r\n    writable: true\r\n  });\r\n\r\n  self._connections++;\r\n  socket.server = self;\r\n  socket._server = self;\r\n\r\n  DTRACE_NET_SERVER_CONNECTION(socket);\r\n  self.emit('connection', socket);\r\n}
          },
          "_usingWorkers": false,
          "_workers": [],
          "_unref": false,
          "allowHalfOpen": true,
          "pauseOnConnect": false,
          "httpAllowHalfOpen": false,
          "timeout": 0,
          "keepAliveTimeout": 5000,
          "maxHeadersCount": null,
          "headersTimeout": 60000,
          "requestTimeout": 0,
          "_connectionKey": "6::::3333"
        },
        "parser": {
          "0": function () { [native code] },
          "1": function parserOnHeaders(headers, url) {\r\n  // Once we exceeded headers limit - stop collecting them\r\n  if (this.maxHeaderPairs <= 0 ||\r\n      this._headers.length < this.maxHeaderPairs) {\r\n    this._headers = this._headers.concat(headers);\r\n  }\r\n  this._url += url;\r\n},
          "2": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\r\n                                 url, statusCode, statusMessage, upgrade,\r\n                                 shouldKeepAlive) {\r\n  const parser = this;\r\n  const { socket } = parser;\r\n\r\n  if (headers === undefined) {\r\n    headers = parser._headers;\r\n    parser._headers = [];\r\n  }\r\n\r\n  if (url === undefined) {\r\n    url = parser._url;\r\n    parser._url = '';\r\n  }\r\n\r\n  // Parser is also used by http client\r\n  const ParserIncomingMessage = (socket && socket.server &&\r\n                                 socket.server[kIncomingMessage]) ||\r\n                                 IncomingMessage;\r\n\r\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\r\n  incoming.httpVersionMajor = versionMajor;\r\n  incoming.httpVersionMinor = versionMinor;\r\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\r\n  incoming.url = url;\r\n  incoming.upgrade = upgrade;\r\n\r\n  if (socket) {\r\n    debug('requestTimeout timer moved to req');\r\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\r\n    incoming.socket[kRequestTimeout] = undefined;\r\n  }\r\n\r\n  let n = headers.length;\r\n\r\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\r\n  if (parser.maxHeaderPairs > 0)\r\n    n = MathMin(n, parser.maxHeaderPairs);\r\n\r\n  incoming._addHeaderLines(headers, n);\r\n\r\n  if (typeof method === 'number') {\r\n    // server only\r\n    incoming.method = methods[method];\r\n  } else {\r\n    // client only\r\n    incoming.statusCode = statusCode;\r\n    incoming.statusMessage = statusMessage;\r\n  }\r\n\r\n  return parser.onIncoming(incoming, shouldKeepAlive);\r\n},
          "3": function parserOnBody(b, start, len) {\r\n  const stream = this.incoming;\r\n\r\n  // If the stream has already been removed, then drop it.\r\n  if (stream === null)\r\n    return;\r\n\r\n  // Pretend this was the result of a stream._read call.\r\n  if (len > 0 && !stream._dumped) {\r\n    const slice = b.slice(start, start + len);\r\n    const ret = stream.push(slice);\r\n    if (!ret)\r\n      readStop(this.socket);\r\n  }\r\n},
          "4": function parserOnMessageComplete() {\r\n  const parser = this;\r\n  const stream = parser.incoming;\r\n\r\n  if (stream !== null) {\r\n    stream.complete = true;\r\n    // Emit any trailing headers.\r\n    const headers = parser._headers;\r\n    if (headers.length) {\r\n      stream._addHeaderLines(headers, headers.length);\r\n      parser._headers = [];\r\n      parser._url = '';\r\n    }\r\n\r\n    // For emit end event\r\n    stream.push(null);\r\n  }\r\n\r\n  // Force to read the next incoming message\r\n  readStart(parser.socket);\r\n},
          "5": function () { [native code] },
          "6": function () { [native code] },
          "_headers": [],
          "_url": "",
          "socket": "[Circular ~.res.req.client]",
          "incoming": "[Circular ~.res.req]",
          "outgoing": null,
          "maxHeaderPairs": 2000,
          "_consumed": true,
          "onIncoming": function () { [native code] }
        },
        "on": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
        "addListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
        "prependListener": function socketListenerWrap(ev, fn) {\r\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\r\n    if (!this.parser) {\r\n      this.on = net.Socket.prototype.on;\r\n      this.addListener = net.Socket.prototype.addListener;\r\n      this.prependListener = net.Socket.prototype.prependListener;\r\n      return res;\r\n    }\r\n\r\n    if (ev === 'data' || ev === 'readable')\r\n      unconsume(this.parser, this);\r\n\r\n    return res;\r\n  },
        "setEncoding": function socketSetEncoding() {\r\n  throw new ERR_HTTP_SOCKET_ENCODING();\r\n},
        "_paused": false,
        "_httpMessage": "[Circular ~.res]",
        "timeout": 0,
        "_peername": {
          "address": "::1",
          "family": "IPv6",
          "port": 7763
        }
      },
      "_consuming": false,
      "_dumped": false,
      "next": function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  },
      "baseUrl": "",
      "originalUrl": "/favicon.ico",
      "_parsedUrl": {
        "protocol": null,
        "slashes": null,
        "auth": null,
        "host": null,
        "port": null,
        "hostname": null,
        "hash": null,
        "search": null,
        "query": null,
        "pathname": "/favicon.ico",
        "path": "/favicon.ico",
        "href": "/favicon.ico",
        "_raw": "/favicon.ico"
      },
      "params": {},
      "query": {},
      "res": "[Circular ~.res]",
      "body": {}
    },
    "locals": {}
  },
  "body": {},
  "statusCode" [31m[1][0m: null
}
[31m
[1] "statusCode" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511][0m
